// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: protobufs/tee_time/tee_time.proto

package tee_time

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	TeeTimeService_GetTeeTimeByDateTime_FullMethodName  = "/tee_time.TeeTimeService/GetTeeTimeByDateTime"
	TeeTimeService_GetTeeTimes_FullMethodName           = "/tee_time.TeeTimeService/GetTeeTimes"
	TeeTimeService_GetTeeTimeSchedules_FullMethodName   = "/tee_time.TeeTimeService/GetTeeTimeSchedules"
	TeeTimeService_CreateTeeTimeSchedule_FullMethodName = "/tee_time.TeeTimeService/CreateTeeTimeSchedule"
	TeeTimeService_GetTeeTimeOverrides_FullMethodName   = "/tee_time.TeeTimeService/GetTeeTimeOverrides"
	TeeTimeService_InvalidateCache_FullMethodName       = "/tee_time.TeeTimeService/InvalidateCache"
)

// TeeTimeServiceClient is the client API for TeeTimeService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TeeTimeServiceClient interface {
	GetTeeTimeByDateTime(ctx context.Context, in *GetTeeTimeDateRequest, opts ...grpc.CallOption) (*GetTeeTimeResponse, error)
	GetTeeTimes(ctx context.Context, in *GetTeeTimesRequest, opts ...grpc.CallOption) (*GetTeeTimesResponse, error)
	GetTeeTimeSchedules(ctx context.Context, in *GetTeeTimeScheduleRequest, opts ...grpc.CallOption) (*GeeTeeTimeScheduleResponse, error)
	CreateTeeTimeSchedule(ctx context.Context, in *CreateTeeTimeScheduleRequest, opts ...grpc.CallOption) (*CreateTeeTimeScheduleResponse, error)
	GetTeeTimeOverrides(ctx context.Context, in *GetTeeTimeOverridesRequest, opts ...grpc.CallOption) (*GetTeeTimeOverridesRequest, error)
	InvalidateCache(ctx context.Context, in *InvalidateCacheRequest, opts ...grpc.CallOption) (*InvalidateCacheResponse, error)
}

type teeTimeServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTeeTimeServiceClient(cc grpc.ClientConnInterface) TeeTimeServiceClient {
	return &teeTimeServiceClient{cc}
}

func (c *teeTimeServiceClient) GetTeeTimeByDateTime(ctx context.Context, in *GetTeeTimeDateRequest, opts ...grpc.CallOption) (*GetTeeTimeResponse, error) {
	out := new(GetTeeTimeResponse)
	err := c.cc.Invoke(ctx, TeeTimeService_GetTeeTimeByDateTime_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teeTimeServiceClient) GetTeeTimes(ctx context.Context, in *GetTeeTimesRequest, opts ...grpc.CallOption) (*GetTeeTimesResponse, error) {
	out := new(GetTeeTimesResponse)
	err := c.cc.Invoke(ctx, TeeTimeService_GetTeeTimes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teeTimeServiceClient) GetTeeTimeSchedules(ctx context.Context, in *GetTeeTimeScheduleRequest, opts ...grpc.CallOption) (*GeeTeeTimeScheduleResponse, error) {
	out := new(GeeTeeTimeScheduleResponse)
	err := c.cc.Invoke(ctx, TeeTimeService_GetTeeTimeSchedules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teeTimeServiceClient) CreateTeeTimeSchedule(ctx context.Context, in *CreateTeeTimeScheduleRequest, opts ...grpc.CallOption) (*CreateTeeTimeScheduleResponse, error) {
	out := new(CreateTeeTimeScheduleResponse)
	err := c.cc.Invoke(ctx, TeeTimeService_CreateTeeTimeSchedule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teeTimeServiceClient) GetTeeTimeOverrides(ctx context.Context, in *GetTeeTimeOverridesRequest, opts ...grpc.CallOption) (*GetTeeTimeOverridesRequest, error) {
	out := new(GetTeeTimeOverridesRequest)
	err := c.cc.Invoke(ctx, TeeTimeService_GetTeeTimeOverrides_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *teeTimeServiceClient) InvalidateCache(ctx context.Context, in *InvalidateCacheRequest, opts ...grpc.CallOption) (*InvalidateCacheResponse, error) {
	out := new(InvalidateCacheResponse)
	err := c.cc.Invoke(ctx, TeeTimeService_InvalidateCache_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TeeTimeServiceServer is the server API for TeeTimeService service.
// All implementations must embed UnimplementedTeeTimeServiceServer
// for forward compatibility
type TeeTimeServiceServer interface {
	GetTeeTimeByDateTime(context.Context, *GetTeeTimeDateRequest) (*GetTeeTimeResponse, error)
	GetTeeTimes(context.Context, *GetTeeTimesRequest) (*GetTeeTimesResponse, error)
	GetTeeTimeSchedules(context.Context, *GetTeeTimeScheduleRequest) (*GeeTeeTimeScheduleResponse, error)
	CreateTeeTimeSchedule(context.Context, *CreateTeeTimeScheduleRequest) (*CreateTeeTimeScheduleResponse, error)
	GetTeeTimeOverrides(context.Context, *GetTeeTimeOverridesRequest) (*GetTeeTimeOverridesRequest, error)
	InvalidateCache(context.Context, *InvalidateCacheRequest) (*InvalidateCacheResponse, error)
	mustEmbedUnimplementedTeeTimeServiceServer()
}

// UnimplementedTeeTimeServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTeeTimeServiceServer struct {
}

func (UnimplementedTeeTimeServiceServer) GetTeeTimeByDateTime(context.Context, *GetTeeTimeDateRequest) (*GetTeeTimeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeeTimeByDateTime not implemented")
}
func (UnimplementedTeeTimeServiceServer) GetTeeTimes(context.Context, *GetTeeTimesRequest) (*GetTeeTimesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeeTimes not implemented")
}
func (UnimplementedTeeTimeServiceServer) GetTeeTimeSchedules(context.Context, *GetTeeTimeScheduleRequest) (*GeeTeeTimeScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeeTimeSchedules not implemented")
}
func (UnimplementedTeeTimeServiceServer) CreateTeeTimeSchedule(context.Context, *CreateTeeTimeScheduleRequest) (*CreateTeeTimeScheduleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTeeTimeSchedule not implemented")
}
func (UnimplementedTeeTimeServiceServer) GetTeeTimeOverrides(context.Context, *GetTeeTimeOverridesRequest) (*GetTeeTimeOverridesRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTeeTimeOverrides not implemented")
}
func (UnimplementedTeeTimeServiceServer) InvalidateCache(context.Context, *InvalidateCacheRequest) (*InvalidateCacheResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvalidateCache not implemented")
}
func (UnimplementedTeeTimeServiceServer) mustEmbedUnimplementedTeeTimeServiceServer() {}

// UnsafeTeeTimeServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TeeTimeServiceServer will
// result in compilation errors.
type UnsafeTeeTimeServiceServer interface {
	mustEmbedUnimplementedTeeTimeServiceServer()
}

func RegisterTeeTimeServiceServer(s grpc.ServiceRegistrar, srv TeeTimeServiceServer) {
	s.RegisterService(&TeeTimeService_ServiceDesc, srv)
}

func _TeeTimeService_GetTeeTimeByDateTime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeeTimeDateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeeTimeServiceServer).GetTeeTimeByDateTime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeeTimeService_GetTeeTimeByDateTime_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeeTimeServiceServer).GetTeeTimeByDateTime(ctx, req.(*GetTeeTimeDateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeeTimeService_GetTeeTimes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeeTimesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeeTimeServiceServer).GetTeeTimes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeeTimeService_GetTeeTimes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeeTimeServiceServer).GetTeeTimes(ctx, req.(*GetTeeTimesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeeTimeService_GetTeeTimeSchedules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeeTimeScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeeTimeServiceServer).GetTeeTimeSchedules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeeTimeService_GetTeeTimeSchedules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeeTimeServiceServer).GetTeeTimeSchedules(ctx, req.(*GetTeeTimeScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeeTimeService_CreateTeeTimeSchedule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTeeTimeScheduleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeeTimeServiceServer).CreateTeeTimeSchedule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeeTimeService_CreateTeeTimeSchedule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeeTimeServiceServer).CreateTeeTimeSchedule(ctx, req.(*CreateTeeTimeScheduleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeeTimeService_GetTeeTimeOverrides_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTeeTimeOverridesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeeTimeServiceServer).GetTeeTimeOverrides(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeeTimeService_GetTeeTimeOverrides_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeeTimeServiceServer).GetTeeTimeOverrides(ctx, req.(*GetTeeTimeOverridesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TeeTimeService_InvalidateCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvalidateCacheRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TeeTimeServiceServer).InvalidateCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TeeTimeService_InvalidateCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TeeTimeServiceServer).InvalidateCache(ctx, req.(*InvalidateCacheRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TeeTimeService_ServiceDesc is the grpc.ServiceDesc for TeeTimeService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TeeTimeService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "tee_time.TeeTimeService",
	HandlerType: (*TeeTimeServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTeeTimeByDateTime",
			Handler:    _TeeTimeService_GetTeeTimeByDateTime_Handler,
		},
		{
			MethodName: "GetTeeTimes",
			Handler:    _TeeTimeService_GetTeeTimes_Handler,
		},
		{
			MethodName: "GetTeeTimeSchedules",
			Handler:    _TeeTimeService_GetTeeTimeSchedules_Handler,
		},
		{
			MethodName: "CreateTeeTimeSchedule",
			Handler:    _TeeTimeService_CreateTeeTimeSchedule_Handler,
		},
		{
			MethodName: "GetTeeTimeOverrides",
			Handler:    _TeeTimeService_GetTeeTimeOverrides_Handler,
		},
		{
			MethodName: "InvalidateCache",
			Handler:    _TeeTimeService_InvalidateCache_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protobufs/tee_time/tee_time.proto",
}
