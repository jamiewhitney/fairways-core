// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package repository

import (
	"context"
	"time"
)

const createBooking = `-- name: CreateBooking :execlastid
INSERT INTO bookings(user_id, course_id, golfers, datetime, price, booking_id, stripe_payment_id)
VALUES (?, ?, ?, ?, ?, ?, ?)
`

type CreateBookingParams struct {
	UserID          string
	CourseID        int64
	Golfers         int64
	Datetime        time.Time
	Price           float64
	BookingID       string
	StripePaymentID string
}

func (q *Queries) CreateBooking(ctx context.Context, arg *CreateBookingParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createBooking,
		arg.UserID,
		arg.CourseID,
		arg.Golfers,
		arg.Datetime,
		arg.Price,
		arg.BookingID,
		arg.StripePaymentID,
	)
	if err != nil {
		return 0, err
	}
	return result.LastInsertId()
}

const getABooking = `-- name: GetABooking :one
SELECT id, created_at, updated_at, deleted_at, user_id, course_id, golfers, datetime, price, booking_id, stripe_payment_id, status, confirmed
FROM bookings
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetABooking(ctx context.Context, id int64) (Booking, error) {
	row := q.db.QueryRowContext(ctx, getABooking, id)
	var i Booking
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.UserID,
		&i.CourseID,
		&i.Golfers,
		&i.Datetime,
		&i.Price,
		&i.BookingID,
		&i.StripePaymentID,
		&i.Status,
		&i.Confirmed,
	)
	return i, err
}

const getConfirmedBookingsByDateAndCourse = `-- name: GetConfirmedBookingsByDateAndCourse :many
SELECT id, created_at, updated_at, deleted_at, user_id, course_id, golfers, datetime, price, booking_id, stripe_payment_id, status, confirmed
FROM bookings
WHERE status = 'confirmed'
  AND course_id = ?
  AND DATE(datetime) = ?
`

type GetConfirmedBookingsByDateAndCourseParams struct {
	CourseID int64
	Datetime time.Time
}

func (q *Queries) GetConfirmedBookingsByDateAndCourse(ctx context.Context, arg *GetConfirmedBookingsByDateAndCourseParams) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, getConfirmedBookingsByDateAndCourse, arg.CourseID, arg.Datetime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.CourseID,
			&i.Golfers,
			&i.Datetime,
			&i.Price,
			&i.BookingID,
			&i.StripePaymentID,
			&i.Status,
			&i.Confirmed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserBookings = `-- name: ListUserBookings :many
SELECT id, created_at, updated_at, deleted_at, user_id, course_id, golfers, datetime, price, booking_id, stripe_payment_id, status, confirmed
FROM bookings
WHERE user_id = ?
ORDER BY datetime
`

func (q *Queries) ListUserBookings(ctx context.Context, userID string) ([]Booking, error) {
	rows, err := q.db.QueryContext(ctx, listUserBookings, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Booking
	for rows.Next() {
		var i Booking
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.UserID,
			&i.CourseID,
			&i.Golfers,
			&i.Datetime,
			&i.Price,
			&i.BookingID,
			&i.StripePaymentID,
			&i.Status,
			&i.Confirmed,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAndConfirm = `-- name: UpdateAndConfirm :exec
UPDATE bookings
SET status            = 'confirmed',
    confirmed         = 1,
    stripe_payment_id = ?
WHERE id = ?
`

type UpdateAndConfirmParams struct {
	StripePaymentID string
	ID              int64
}

func (q *Queries) UpdateAndConfirm(ctx context.Context, arg *UpdateAndConfirmParams) error {
	_, err := q.db.ExecContext(ctx, updateAndConfirm, arg.StripePaymentID, arg.ID)
	return err
}

const updateBooking = `-- name: UpdateBooking :exec
UPDATE bookings
SET user_id = ?
WHERE id = ?
`

type UpdateBookingParams struct {
	UserID string
	ID     int64
}

func (q *Queries) UpdateBooking(ctx context.Context, arg *UpdateBookingParams) error {
	_, err := q.db.ExecContext(ctx, updateBooking, arg.UserID, arg.ID)
	return err
}
